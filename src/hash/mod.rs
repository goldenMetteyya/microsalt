//! -----------------------------------------
//! |`crypto_hash`        |primitive |BYTES |
//! |---------------------|----------|------|
//! |`crypto_hash_sha512` |`SHA-512` |64    |
//! -----------------------------------------

mod sha512;

//Public hash API
pub fn hasher(data: &[u8]) -> [u8; sha512::HASH_LENGTH] {
    let mut result = [0u8; sha512::HASH_LENGTH];

    sha512::hash(&mut result, data);

    //return back hash  
    result
}

pub fn raw_sha512(out: &mut [u8; 64], m: &[u8]){ sha512::hash(out, m); }

mod test {
    #[test]
    fn test_hash_sanity() {
        //https://github.com/erik/knuckle/blob/master/src/hash.rs
        // corresponding to tests/hash.c, tests/hash2.cpp,
        // tests/hash3.c and tests/hash4.cpp from NaCl
        let x = [0x74, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x67, 0xa];
        let expected = [0x24, 0xf9, 0x50, 0xaa, 0xc7, 0xb9, 0xea, 0x9b,
                        0x3c, 0xb7, 0x28, 0x22, 0x8a, 0x0c, 0x82, 0xb6,
                        0x7c, 0x39, 0xe9, 0x6b, 0x4b, 0x34, 0x47, 0x98,
                        0x87, 0x0d, 0x5d, 0xae, 0xe9, 0x3e, 0x3a, 0xe5,
                        0x93, 0x1b, 0xaa, 0xe8, 0xc7, 0xca, 0xcf, 0xea,
                        0x4b, 0x62, 0x94, 0x52, 0xc3, 0x80, 0x26, 0xa8,
                        0x1d, 0x13, 0x8b, 0xc7, 0xaa, 0xd1, 0xaf, 0x3e,
                        0xf7, 0xbf, 0xd5, 0xec, 0x64, 0x6d, 0x6c, 0x28];

        assert_eq!(&super::hasher(&x)[..], &expected[..]);
    }

    //http://www.di-mgt.com.au/sha_testvectors.html
    #[test]
    fn test_hash_abc() {
        let abc = [0x61, 0x62, 0x63]; //length 24 bits
        let expected = [0xdd, 0xaf, 0x35, 0xa1, 0x93, 0x61, 0x7a, 0xba, 
                        0xcc, 0x41, 0x73, 0x49, 0xae, 0x20, 0x41, 0x31, 
                        0x12, 0xe6, 0xfa, 0x4e, 0x89, 0xa9, 0x7e, 0xa2, 
                        0x0a, 0x9e, 0xee, 0xe6, 0x4b, 0x55, 0xd3, 0x9a, 
                        0x21, 0x92, 0x99, 0x2a, 0x27, 0x4f, 0xc1, 0xa8, 
                        0x36, 0xba, 0x3c, 0x23, 0xa3, 0xfe, 0xeb, 0xbd, 
                        0x45, 0x4d, 0x44, 0x23, 0x64, 0x3c, 0xe8, 0x0e, 
                        0x2a, 0x9a, 0xc9, 0x4f, 0xa5, 0x4c, 0xa4, 0x9f];
        
        assert_eq!(&super::hasher(&abc)[..], &expected[..]);
    }

    #[test]
    fn test_hash_448() {
        //char 'a' = 0x61
        let a = String::from("abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"); //length 448 bits
        let expected = [0x20, 0x4a, 0x8f, 0xc6, 0xdd, 0xa8, 0x2f, 0x0a,
                        0x0c, 0xed, 0x7b, 0xeb, 0x8e, 0x08, 0xa4, 0x16,
                        0x57, 0xc1, 0x6e, 0xf4, 0x68, 0xb2, 0x28, 0xa8,
                        0x27, 0x9b, 0xe3, 0x31, 0xa7, 0x03, 0xc3, 0x35,
                        0x96, 0xfd, 0x15, 0xc1, 0x3b, 0x1b, 0x07, 0xf9,
                        0xaa, 0x1d, 0x3b, 0xea, 0x57, 0x78, 0x9c, 0xa0,
                        0x31, 0xad, 0x85, 0xc7, 0xa7, 0x1d, 0xd7, 0x03,
                        0x54, 0xec, 0x63, 0x12, 0x38, 0xca, 0x34, 0x45]; 

        assert_eq!(&super::hasher(&a.as_bytes())[..], &expected[..]);
    }
}
